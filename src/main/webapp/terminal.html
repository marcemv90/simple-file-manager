<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web Terminal</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Materialize CSS (for basic button styling, optional) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #111;
            color: #eee;
            font-family: monospace;
            overflow: hidden;
        }
        .terminal-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
        }
        #terminal {
            flex: 1;
            padding: 4px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
<div class="terminal-container">
    <div id="terminal"></div>
</div>

<!-- Dependencies -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

<script>
    (function() {
        const term = new Terminal({
            cursorBlink: true,
            theme: {
                background: '#111111',
                foreground: '#EEEEEE'
            }
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        const loc = window.location;
        const wsProtocol = loc.protocol === 'https:' ? 'wss:' : 'ws:';
        const basePath = loc.pathname.replace(/terminal\.html$/, '');
        const wsUrl = wsProtocol + '//' + loc.host + basePath + 'ws-shell';

        const socket = new WebSocket(wsUrl);

        function sendResize(cols, rows) {
            if (socket.readyState === WebSocket.OPEN && cols > 0 && rows > 0) {
                socket.send('RESIZE ' + cols + ' ' + rows);
            }
        }

        socket.onopen = function() {
            term.focus();
            const dims = fitAddon.proposeDimensions();
            if (dims && dims.cols && dims.rows) {
                term.resize(dims.cols, dims.rows);
                sendResize(dims.cols, dims.rows);
            } else if (term.cols && term.rows) {
                sendResize(term.cols, term.rows);
            }
        };

        socket.onmessage = function(ev) {
            term.write(ev.data);
        };

        socket.onclose = function() {
            term.write('\r\n[Session closed]\r\n');
        };

        socket.onerror = function() {
            term.write('\r\n[Connection error]\r\n');
        };

        term.onData(function(data) {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(data);
            }
        });

        term.onSelectionChange(function() {
            const selection = term.getSelection();
            if (!selection) {
                return;
            }
            if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(selection).catch(function() {
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = selection;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.focus();
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                    } catch (e) {
                        // ignore copy failures
                    }
                });
            }
        });

        term.onResize(function(size) {
            if (!size) return;
            sendResize(size.cols, size.rows);
        });

        window.addEventListener('resize', function() {
            fitAddon.fit();
            const dims = fitAddon.proposeDimensions();
            if (dims && dims.cols && dims.rows) {
                term.resize(dims.cols, dims.rows);
                sendResize(dims.cols, dims.rows);
            }
        });
    })();
</script>
</body>
</html>
